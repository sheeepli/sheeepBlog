---
title: 关于设计模式的那些事
date: 2021-05-16 16:53:46
tags: 基础
---

> 隐约雷鸣，阴霾天空，但盼风雨来，能留你在此
> 隐约雷鸣，阴霾天空，即使天无雨，我亦留此地

## 创建型模式

### 工厂模式

**工厂方法模式**是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

使用场景：

1. 当你在编写代码的过程中，无法预知对象确切类别及其依赖关系时。
2. 如果你希望用户能扩展你软件库或框架的内部组件。
3. 如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象。

实现方法：

1. 让所有产品都遵循同一接口。该接口必须声明对所有产品都有意义的方法。
2. 在创建类中添加一个空的工厂方法。该方法饭的饭会类型必须遵循通用的产品接口。
3. 在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用，同时将产品的代码移入工厂方法。你可能需要在工厂方法中添加临时参数俩控制饭会的产品类型。
4. 为工厂方法中的每种产品编写一个创建者子类，然后在子类中重写工厂方法，并将基于方法中的相关创建代码移动到工厂方法中。
5. 如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时可以在子类中复用基类中的控制参数。

    例如，设想你有以下一些层次结构的类。基类`邮件`及其子类`航空邮件`和`陆路邮件`；`运输`及其子类`飞机`，`卡车`，`火车`。`航空邮件`仅使用`飞机`对象，而`陆路邮件`则会同时使用`卡车`和`火车`对象。你可以编写一个新的子类（例如`火车邮件`）来处理这两种情况，但是还有其他可选的方案。客户端代码可以给`陆路邮件`类传递一个参数，用于控制其希望获得的产品。

6. 如果代码经过上述移动后，基础工厂方法中已经没有任何代码，你可以将其转变为抽象类。如果基础工厂方法中还有其他语句，你可以将其设置为该方法的默认行为。

<!-- more -->

### 抽象工厂模式

**抽象工厂模式**是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。

使用场景：

1. 如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者处于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建。
2. 如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确。

实现方法：

1. 以不同的产品类型与产品变体为维度绘制矩阵。
2. 为所有产品声明抽象产品接口。然后让所有具体产品类实现这些接口。
3. 声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构建方法。
4. 为每种产品变体实现一个具体工厂类。
5. 在应用程序中开发初始化代码。改代码根据应用程序配置或当前环境，对特定具体工厂类进行初始化。然后该工厂对象床底给所有需要创建产品的类。
6. 找出代码中所有对产品构造函数的直接调用，将其替换为对工厂对象中相应构建方法的调用。

### 生成器模式

**生成器模式**时一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你是用相同的创建代码生成不同类型和形式的对象。

使用场景：

1. 使用生成器模式可避免“重叠构造函数”的出现。
2. 当你希望使用代码创建不同形式的产品（例如石头或木头房屋）时。

    如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。

3. 使用生成器构造组合树或其他复杂对象。

实现方法：

1. 清晰地定义通用步骤，确保它们可以制造所有形式的产品。否则你将无法进一步实施该模式。
2. 在基本生成器接口中声明这些步骤。
3. 为每个形式的产品创建具体生成器类，并实现其构造步骤。
4. 考虑创建主管类。它可以使用同一生成器对象来封装多种构造产品的方式。
5. 客户端代码会同时创建生成器和主管对象。构造开始前，客户端必须将生成器对象传递给主管对象。通常情况下，客户端只需要调用主管类构造函数一次即可。主管类使用生成器对象完成后续所有制造任务。还有一种方式，那就是客户端可以将生成器对象直接传递给主管类的制造方法。
6. 只有在所有产品都遵循相同接口的情况下，构造结果可以直接通过主管类获取。否则，客户端应当通过生成器获取构造结果。

原文参加[Refactoring.Guru](https://refactoringguru.cn/)