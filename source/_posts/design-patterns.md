---
title: 关于设计模式的那些事
date: 2021-05-16 16:53:46
tags: 基础
---

> 隐约雷鸣，阴霾天空，但盼风雨来，能留你在此
> 隐约雷鸣，阴霾天空，即使天无雨，我亦留此地

## 创建型模式

### [工厂模式](https://refactoringguru.cn/design-patterns/factory-method)

**工厂方法模式**是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

使用场景：

1. 当你在编写代码的过程中，无法预知对象确切类别及其依赖关系时。
2. 如果你希望用户能扩展你软件库或框架的内部组件。
3. 如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象。

实现方法：

1. 让所有产品都遵循同一接口。该接口必须声明对所有产品都有意义的方法。
2. 在创建类中添加一个空的工厂方法。该方法饭的饭会类型必须遵循通用的产品接口。
3. 在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用，同时将产品的代码移入工厂方法。你可能需要在工厂方法中添加临时参数俩控制饭会的产品类型。
4. 为工厂方法中的每种产品编写一个创建者子类，然后在子类中重写工厂方法，并将基于方法中的相关创建代码移动到工厂方法中。
5. 如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时可以在子类中复用基类中的控制参数。

    例如，设想你有以下一些层次结构的类。基类`邮件`及其子类`航空邮件`和`陆路邮件`；`运输`及其子类`飞机`，`卡车`，`火车`。`航空邮件`仅使用`飞机`对象，而`陆路邮件`则会同时使用`卡车`和`火车`对象。你可以编写一个新的子类（例如`火车邮件`）来处理这两种情况，但是还有其他可选的方案。客户端代码可以给`陆路邮件`类传递一个参数，用于控制其希望获得的产品。

6. 如果代码经过上述移动后，基础工厂方法中已经没有任何代码，你可以将其转变为抽象类。如果基础工厂方法中还有其他语句，你可以将其设置为该方法的默认行为。

<!-- more -->

### [抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)

**抽象工厂模式**是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。

使用场景：

1. 如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者处于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建。
2. 如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确。

实现方法：

1. 以不同的产品类型与产品变体为维度绘制矩阵。
2. 为所有产品声明抽象产品接口。然后让所有具体产品类实现这些接口。
3. 声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构建方法。
4. 为每种产品变体实现一个具体工厂类。
5. 在应用程序中开发初始化代码。改代码根据应用程序配置或当前环境，对特定具体工厂类进行初始化。然后该工厂对象床底给所有需要创建产品的类。
6. 找出代码中所有对产品构造函数的直接调用，将其替换为对工厂对象中相应构建方法的调用。

### [生成器模式（建造者设计模式）](https://refactoringguru.cn/design-patterns/builder)

**生成器模式**是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你是用相同的创建代码生成不同类型和形式的对象。

使用场景：

1. 使用生成器模式可避免“重叠构造函数”的出现。
2. 当你希望使用代码创建不同形式的产品（例如石头或木头房屋）时。

    如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。

3. 使用生成器构造组合树或其他复杂对象。

实现方法：

1. 清晰地定义通用步骤，确保它们可以制造所有形式的产品。否则你将无法进一步实施该模式。
2. 在基本生成器接口中声明这些步骤。
3. 为每个形式的产品创建具体生成器类，并实现其构造步骤。
4. 考虑创建主管类。它可以使用同一生成器对象来封装多种构造产品的方式。
5. 客户端代码会同时创建生成器和主管对象。构造开始前，客户端必须将生成器对象传递给主管对象。通常情况下，客户端只需要调用主管类构造函数一次即可。主管类使用生成器对象完成后续所有制造任务。还有一种方式，那就是客户端可以将生成器对象直接传递给主管类的制造方法。
6. 只有在所有产品都遵循相同接口的情况下，构造结果可以直接通过主管类获取。否则，客户端应当通过生成器获取构造结果。

原文参加[Refactoring.Guru](https://refactoringguru.cn/) 

### [原型设计模式](https://refactoringguru.cn/design-patterns/prototype)

**原型模式**是一种创建型设计模式，使你能够复制已有对象，而又无需使代码上依赖它所属的类。

即，构造函数向外暴露出一个 clone（暂且叫这个名字吧）的方法，实例对象创建的时候也有这个方法，可以通过示例对象的 clone 去克隆出一个一样的对象，而不用去重新实例化一个。其中引用类型的克隆是在堆里面直接新开一个空间来存放的，而不是跟第一个示例对象一样的地址。

使用场景：

1. 如果你需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式。
2. 如果子类的区别仅在于其对象的初始化方式，那么你可以使用该模式来减少子类的数量。别人创建这些子类的目的可能是为了创建特定类型的对象。

实现方法：

1. 创建原型接口，并在其中声明*克隆*方法。如果你已有类层次结构，则只需在其所有类中添加该方法即可。
2. 圆形类必须另行定义一个以该类对象为参数的构造函数。构造函数必须复制参数对象中的所有成员变量值到新建实体中。如果你需要修改子类，则必须调用父类构造函数，让父类复制其私有成员变量值。
3. 克隆方法通常只需要一行代码：使用`new`运算符调用原型版本的构造函数。注意，每个类都必须显示重写克隆方法并使用自身类名调用`new`运算符。否则克隆方法可能会生成父类的对象。
4. 你还可以创建一个中心化原型注册表，用于存储常用原型。

### [单例模式](https://refactoringguru.cn/design-patterns/singleton)

**单例模式**是一种创建型设计模式，让你能够保证一个类只有一个示例，并提供一个访问该实例的全局节点。

单例模式同时解决了两个问题（保证一个类只有一个示例，为该示例提供一个全局访问节点），所以违反了**单一职责原则**。

所有的单例的实现都包含一下两个相同的步骤：

* 将默认的构造函数设为私有，防止其他对象使用单例类的`new`运算符。
* 新建一个静态构建方法作为构造函数。该函数会“偷偷”调用私有构造函数来创建对象，并将其保存在要给静态成员变量中。此后所有对于该函数的调用都将返回这一缓存对象。

使用场景：

1. 如果程序后在那个的某个类对于所有客户端都只有一个可用的实例，可以使用单例模式。
2. 如果你需要更加严格地控制全局变量，可以使用单例模式。

实现方法：

1. 在类中添加一个私有静态成员变量用于保存单例实例。
2. 声明一个公有静态构建方法用于获取单例实例。
3. 在静态方法中实现“盐池初始化”。该方法每次被调用时都返回该实例。
4. 该类的构造函数设为私有。类的静态方法仍能调用构造函数，但是其他对象不能调用。
5. 检查客户端代码，将对单例的构造函数的调用替换为对静态构建方法的调用。
